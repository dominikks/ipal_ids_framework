import json
import math
from combiner.combiner import Combiner
from ipal_iids.utils import open_file
import ipal_iids.settings as settings
import itertools


class OptimalBruteForceCombiner(Combiner):
    """
    This combiner bruteforces the optimal combiner function {0, 1}^N -> {0, 1} (where N is the number of IDSs).
    This means it has to try 2^2^N combinations, which is exponential in N. Thus, its infeasible in many cases.

    It minimizes the number of missclassifications, which maximizes accuracy.
    """

    _name = "OptimalBruteForceCombiner"

    def __init__(self, name=None):
        super().__init__(name=name)

        # List of IDS names (used to establish an ordering)
        self._ids_order = None
        # A list of outputs corresponding to the inputs returned from self._get_input_order
        self._combiner_fct = None

    def _get_input_order(self):
        # All possible inputs that can be generated by the IDSs (count: 2^len(idss)).
        # Sequentialized into a list.
        return list(itertools.product([0, 1], repeat=len(self._ids_order)))

    def train(self, idss, ipal=None, state=None):
        if ipal and state:
            settings.logger.error("Only state or message supported")
            exit(1)

        # Only the IDSs compatible with the selected format (message or state)
        idss = [
            ids for ids in idss if ids.requires("live.ipal" if ipal else "live.state")
        ]

        settings.logger.debug(
            "Loading dataset and running IDSs for combiner training..."
        )

        # Load train set and apply idss on it
        msgs = []
        with open_file(state if state else ipal) as file:
            for msg in file.readlines():
                msg = json.loads(msg)
                alerts = []

                for ids in idss:
                    alert, metric = (
                        ids.new_state_msg(msg) if state else ids.new_ipal_msg(msg)
                    )
                    alerts.append(alert)

                msg["ids-outputs"] = alerts
                msgs.append(msg)

        # Save the order of the IDSs
        self._ids_order = [ids._name for ids in idss]

        # All possible IDS outputs (which are inputs to the combiner)
        input_order = self._get_input_order()

        settings.logger.info("Starting combiner training...")

        # Track current progress
        best_fct = None
        best_missclassification_count = math.inf

        # Iterate through all possible assignments of outputs ([0, 1]) to inputs
        for output_assignment in itertools.product([0, 1], repeat=len(input_order)):
            missclassification_count = 0

            for msg in msgs:
                input_index = input_order.index(tuple(msg["ids-outputs"]))
                output = output_assignment[input_index]

                malicious = msg["malicious"] is not False
                if output != malicious:
                    missclassification_count += 1

            if missclassification_count < best_missclassification_count:
                best_missclassification_count = missclassification_count
                best_fct = output_assignment

        settings.logger.info("Combiner training done")

        # Save optimal fct
        self._combiner_fct = best_fct

    def combine(self, msg):
        inputs = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)

        input_order = self._get_input_order()
        input_index = input_order.index(inputs)

        alert = self._combiner_fct[input_index]

        return alert, 1 if alert else 0

    def _get_model(self):
        return {"function": self._combiner_fct, "ids_order": self._ids_order}

    def _load_model(self, model):
        self._combiner_fct = model["function"]
        self._ids_order = model["ids_order"]
