import json
import math
from combiner.combiner import Combiner
from ipal_iids.utils import open_file
import ipal_iids.settings as settings
import itertools


class OptimalHeuristicCombiner(Combiner):
    """
    This combiner implements a heuristic that minimizes the number of missclassifications, which maximizes accuracy.
    """

    _name = "OptimalHeuristicCombiner"

    def __init__(self, name=None):
        super().__init__(name=name)

        # List of IDS names (used to establish an ordering)
        self._ids_order = None
        # A list of outputs corresponding to the inputs returned from self._get_input_order
        self._combiner_fct = None

    def _get_input_order(self):
        # All possible inputs that can be generated by the IDSs (count: 2^len(idss)).
        # Sequentialized into a list.
        return list(itertools.product([0, 1], repeat=len(self._ids_order)))

    def train(self, idss, ipal=None, state=None):
        if ipal and state:
            settings.logger.error("Only state or message supported")
            exit(1)

        # Only the IDSs compatible with the selected format (message or state)
        idss = [
            ids for ids in idss if ids.requires("live.ipal" if ipal else "live.state")
        ]

        # Save the order of the IDSs
        self._ids_order = [ids._name for ids in idss]

        # All possible IDS outputs (which are inputs to the combiner)
        inputs = self._get_input_order()

        settings.logger.debug(
            "Loading dataset and running IDSs for combiner training..."
        )

        # For each tuple of IDS inputs, we count how many times it is malicious and how many times it is benign
        input_stats = {input: {"malicious": 0, "benign": 0} for input in inputs}

        with open_file(state if state else ipal) as file:
            for msg in file.readlines():
                msg = json.loads(msg)
                alerts = []

                for ids in idss:
                    alert, metric = (
                        ids.new_state_msg(msg) if state else ids.new_ipal_msg(msg)
                    )
                    alerts.append(alert)

                input = tuple(alerts)
                input_stats[input][
                    "malicious" if msg["malicious"] is not False else "benign"
                ] += 1

        settings.logger.info("Computing optimal combiner...")

        # Assign an output to each input based on if there are more malicious or benign packets with that input
        outputs = []
        for input in inputs:
            stats = input_stats[input]
            outputs.append(stats["malicious"] >= stats["benign"])

        self._combiner_fct = outputs

        settings.logger.info("Combiner training done")

    def combine(self, msg):
        inputs = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)

        input_order = self._get_input_order()
        input_index = input_order.index(inputs)

        alert = self._combiner_fct[input_index]

        return alert, 1 if alert else 0

    def _get_model(self):
        return {"function": self._combiner_fct, "ids_order": self._ids_order}

    def _load_model(self, model):
        self._combiner_fct = model["function"]
        self._ids_order = model["ids_order"]
