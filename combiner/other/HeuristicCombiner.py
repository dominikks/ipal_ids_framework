import csv
from combiner.combiner import Combiner
from ipal_iids.utils import open_file
import ipal_iids.settings as settings
import itertools


class HeuristicCombiner(Combiner):
    """
    This combiner implements a heuristic that minimizes the number of missclassifications, which maximizes accuracy.
    """

    _name = "HeuristicCombiner"
    _needs_training = True

    _heuristic_default_settings = {
        # Path to a file where the computed stats are saved during training (as csv)
        "stats-file": None,
        # How to handle the case where there are exactly as many benign as malicious instances corresponding to an input word.
        # (Special case: the input word does not occur in the dataset.)
        # Default: classify as benign (False).
        "tie_breaker": False,
    }

    def __init__(self, name=None):
        super().__init__(name=name)
        self._add_default_settings(self._heuristic_default_settings)

        # List of IDS names (used to establish an ordering)
        self._ids_order = None
        # A list of outputs corresponding to the inputs returned from self._get_input_order
        self._combiner_fct = None

    def _get_input_order(self):
        # All possible inputs that can be generated by the IDSs (count: 2^len(idss)).
        # Sequentialized into a list.
        return list(itertools.product([0, 1], repeat=len(self._ids_order)))

    def train(self, msgs):
        # Save the order of the IDSs
        self._ids_order = list(msgs[0]["alerts"].keys())

        # All possible IDS outputs (which are inputs to the combiner)
        inputs = self._get_input_order()

        # For each tuple of IDS inputs, we count how many times it is benign and how many times it is malicious.
        # First index: benign, second index: malicious
        input_stats = {input: [0, 0] for input in inputs}

        settings.logger.info("Computing statistics over train set...")

        for msg in msgs:
            alerts = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)
            malicious = msg["malicious"] is not False

            input_stats[alerts][int(malicious)] += 1

        if self.settings["stats-file"] is not None:
            settings.logger.info("Dumping computed message statistics to file.")
            with open_file(self.settings["stats-file"], "wt", newline="") as f:
                writer = csv.writer(f)
                writer.writerow([*self._ids_order, "benign", "malicious"])
                writer.writerows(
                    [[*input, *stats] for input, stats in input_stats.items()]
                )

        settings.logger.info("Computing heuristic combiner...")

        # Assign an output to each input based on if there are more malicious or benign packets with that input
        outputs = []
        for input in inputs:
            benign, malicious = input_stats[input]

            if benign == malicious:
                outputs.append(self.settings["tie_breaker"])
            else:
                outputs.append(malicious > benign)

        self._combiner_fct = outputs

        settings.logger.info("Combiner training done")

    def combine(self, msg):
        inputs = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)

        input_order = self._get_input_order()
        input_index = input_order.index(inputs)

        alert = self._combiner_fct[input_index]

        return alert, 1 if alert else 0

    def _get_model(self):
        return {"function": self._combiner_fct, "ids_order": self._ids_order}

    def _load_model(self, model):
        self._combiner_fct = model["function"]
        self._ids_order = model["ids_order"]
