import csv
from combiner.combiner import Combiner
from ipal_iids.utils import open_file
import ipal_iids.settings as settings
import itertools


class HeuristicCombiner(Combiner):
    """
    This combiner implements a heuristic that minimizes the number of missclassifications, which maximizes accuracy.
    """

    _name = "HeuristicCombiner"
    _needs_training = True

    _heuristic_default_settings = {
        "stats-file": None,
    }

    def __init__(self, name=None):
        super().__init__(name=name)
        self._add_default_settings(self._heuristic_default_settings)

        # List of IDS names (used to establish an ordering)
        self._ids_order = None
        # A list of outputs corresponding to the inputs returned from self._get_input_order
        self._combiner_fct = None

    def _get_input_order(self):
        # All possible inputs that can be generated by the IDSs (count: 2^len(idss)).
        # Sequentialized into a list.
        return list(itertools.product([0, 1], repeat=len(self._ids_order)))

    def train(self, msgs):
        # Save the order of the IDSs
        self._ids_order = list(msgs[0]["alerts"].keys())

        # All possible IDS outputs (which are inputs to the combiner)
        inputs = self._get_input_order()

        # For each tuple of IDS inputs, we count how many times it is malicious and how many times it is benign
        input_stats = {input: {"malicious": 0, "benign": 0} for input in inputs}

        settings.logger.info("Computing statistics over train set...")

        for msg in msgs:
            alerts = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)
            input_stats[alerts][
                "malicious" if msg["malicious"] is not False else "benign"
            ] += 1

        if self.settings["stats-file"] is not None:
            settings.logger.info("Dumping computed message statistics to file.")
            with open_file(self.settings["stats-file"], "wt", newline="") as f:
                writer = csv.writer(f)
                writer.writerow([*self._ids_order, "malicious", "benign"])
                writer.writerows(
                    [
                        [*input, stats["malicious"], stats["benign"]]
                        for input, stats in input_stats.items()
                    ]
                )

        settings.logger.info("Computing heuristic combiner...")

        # Assign an output to each input based on if there are more malicious or benign packets with that input
        outputs = []
        for input in inputs:
            stats = input_stats[input]
            outputs.append(stats["malicious"] >= stats["benign"])

        self._combiner_fct = outputs

        settings.logger.info("Combiner training done")

    def combine(self, msg):
        inputs = tuple(msg["alerts"][ids_name] for ids_name in self._ids_order)

        input_order = self._get_input_order()
        input_index = input_order.index(inputs)

        alert = self._combiner_fct[input_index]

        return alert, 1 if alert else 0

    def _get_model(self):
        return {"function": self._combiner_fct, "ids_order": self._ids_order}

    def _load_model(self, model):
        self._combiner_fct = model["function"]
        self._ids_order = model["ids_order"]
